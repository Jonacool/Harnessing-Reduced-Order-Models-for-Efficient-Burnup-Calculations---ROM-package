""" 
written by: Jonathan Pilgram, november '23 - august '24
"""

import numpy as np
import re
import matplotlib.pyplot as plt


"""Various utilities to analyze or support project"""


def read_burnup_file(file_path: str) -> dict:
    """Function to read a burnup step file generated by Serpent (.m format)

    Returns
    -------
    variables : dict
        Dictionairy containing burnup step variables, being
        t : time in seconds (float)
        flx : flux (float) # of what? Maybe neutrons
        N0 : nuclide vector before burnup step (2D array) # sure?
        ZAI : nuclide identification (2D array) # identification system
        A : burnup array (2D array)
        N1 : nuclide vector after burnup step (2D array) # sure?

    Parameters
    ----------
    file_path : str
        The path to the burnup step file"""
    with open(file_path, "r") as file:
        burnup_contents = file.read()
        burnup_contents = burnup_contents.replace(";", "")
        burnup_contents = burnup_contents.replace("(", "[")
        burnup_contents = burnup_contents.replace(")", "]")
        burnup_contents = burnup_contents.replace("%", "#")
        burnup_contents = re.sub(
            r"zeros\[(\d+),\s*(\d+)\]", r"np.zeros((\1,\2))", burnup_contents
        )
        burnup_contents = re.sub(
            r"\[\s*(\d+),\s*(\d+)\]",
            lambda match: "["
            + str(int(match.group(1)) - 1)
            + ","
            + str(int(match.group(2)) - 1)
            + "]",
            burnup_contents,
        )
        burnup_contents = re.sub(
            r"\[\s*(\d+)\]",
            lambda match: "[" + str(int(match.group(1)) - 1) + "]",
            burnup_contents,
        )

    variables = {}
    exec(
        "import numpy as np \n"
        # Insert some definitions as serpent did a silent removal of those
        + "N0 = np.zeros((1650,1)) \n"
        + "ZAI = np.zeros((1650,1)) \n"
        + "N1 = np.zeros((1650,1)) \n"
        + "A = np.zeros((1650,1650)) \n"
        + burnup_contents,
        variables,
    )
    return variables


def print_error(decay_chain, nuclide=None) -> None:
    """Calculates and prints the error of the ROM to FOM

    parameters
    ----------
    nuclide (default None)
        The nuclides to calculate the error for. None (default) gives the total error.
    """

    if nuclide == None:
        error = np.linalg.norm(
            decay_chain.solution.y - decay_chain.solution_red.y
        ) / np.linalg.norm(decay_chain.solution.y)
        print(f"Normalised total error: {error:.3e}")
        return

    for a in nuclide:
        error = np.linalg.norm(
            decay_chain.solution.y[a, :] - decay_chain.solution_red.y[a, :]
        ) / np.linalg.norm(decay_chain.solution.y[a, :])
        print("Normalised error nuclide " + str(a) + f": {error:.3e}")


def return_error(decay_chain, nuclide=None) -> None:
    """Calculates and returns the error of the ROM to FOM

    parameters
    ----------
    nuclide (default None)
        The nuclides to calculate the error for. None (default) gives the total error.
    """

    if nuclide == None:
        error = np.linalg.norm(
            decay_chain.solution.y - decay_chain.solution_red.y
        ) / np.linalg.norm(decay_chain.solution.y)
        return error

    error = np.zeros(len(nuclide))
    for i in range(len(nuclide)):
        a = nuclide[i]
        error[i] = np.linalg.norm(
            decay_chain.solution.y[a, :] - decay_chain.solution_red.y[a, :]
        ) / np.linalg.norm(decay_chain.solution.y[a, :])
    return error


def analyze_eigenvalues(burnup_matrix, info=False, log_scale=False):
    """Function that plots all eigenvalues and prints the positive ones and imaginairy only ones

    parameters
    ----------
    burnup_matrix
        The burnup matrix to analyze
    printout (default False) : bool
        Whether to print or return the analysis
    """
    eigenvalues, eigenvectors = np.linalg.eig(burnup_matrix)
    if info == True:
        plt.scatter(
            np.real(eigenvalues[eigenvalues < 0]),
            np.imag(eigenvalues[eigenvalues < 0]),
            color="blue",
            marker="x",
        )
        plt.scatter(
            np.real(eigenvalues[eigenvalues > 0]),
            np.imag(eigenvalues[eigenvalues > 0]),
            color="red",
            marker="x",
        )
        plt.xlabel("Real Part")
        plt.ylabel("Imaginary Part")
        plt.title("Eigenvalues Plot")
        plt.grid(True)
        if log_scale == True:
            plt.xscale("symlog")
        plt.axhline(0, color="black", linewidth=0.5)
        plt.axvline(0, color="black", linewidth=0.5)
        plt.show()

    positive_eigenvalues = eigenvalues[eigenvalues > 0]
    positive_eigenvectors = eigenvectors[eigenvalues > 0, :]

    imag_eigenvalues = eigenvalues[eigenvalues.real == 0]
    imag_eigenvectors = eigenvectors[eigenvalues.real == 0, :]

    if info == True:
        print("Amount of imaginairy eigenvalues: " + str(len(imag_eigenvalues)))
        if len(imag_eigenvalues) > 0:
            print("All imaginairy eigenvalues now follow")
            for n in range(len(imag_eigenvalues)):
                print("Eigenvalue: " + str(imag_eigenvalues[n]))

        print("Amount of positive eigenvalues: " + str(len(positive_eigenvalues)))
        if len(positive_eigenvalues) > 0:
            print("All positive eigenvalues now follow")
            for n in range(len(positive_eigenvalues)):
                print("Eigenvalue: " + str(positive_eigenvalues[n]))

    return positive_eigenvalues, imag_eigenvalues


def analyze_burnup_array(burnup_array: np.ndarray):
    """Function to analyze a burnup matrix. Analyzes: eigenvalues, eigenvectors, diagonal/off diagonal elements and sum.

    Parameters
    ----------
    burnup array : np.ndarray
        The burnup array to analyze"""

    analyze_eigenvalues(burnup_array, info=True)

    N_diagonal = np.count_nonzero(
        burnup_array[np.eye(burnup_array.shape[0], dtype=bool)]
    )
    diagonal_sum = np.trace(burnup_array)
    N_upper_half = np.count_nonzero(
        burnup_array[np.triu_indices(burnup_array.shape[0], k=1)]
    )
    upper_half_sum = np.sum(burnup_array[np.triu_indices(burnup_array.shape[0], k=1)])
    N_lower_half = np.count_nonzero(
        burnup_array[np.tril_indices(burnup_array.shape[0], k=-1)]
    )
    lower_half_sum = np.sum(burnup_array[np.tril_indices(burnup_array.shape[0], k=-1)])

    print("Amount of non-zero diagonal elements: " + str(N_diagonal))
    print("Diagonal sum: " + str(diagonal_sum))
    print(
        "Amount of non-zero upper half elements (excluding diagonal): "
        + str(N_upper_half)
    )
    print("Upper half sum (excluding diagonal): " + str(upper_half_sum))
    print(
        "Amount of non-zero lower half elements (excluding diagonal): "
        + str(N_lower_half)
    )
    print("Lower half sum (excluding diagonal): " + str(lower_half_sum))


def signif(x, p):
    """Rounds x to p significant digits
    Taken from Scott Gigante's answer: https://stackoverflow.com/questions/18915378/rounding-to-significant-figures-in-numpy
    """
    x = np.asarray(x)
    x_positive = np.where(np.isfinite(x) & (x != 0), np.abs(x), 10 ** (p - 1))
    mags = 10 ** (p - 1 - np.floor(np.log10(x_positive)))
    return np.round(x * mags) / mags
